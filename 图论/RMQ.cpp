/*
首先是预处理，用动态规划（DP）解决。
设A[i]是要求区间最值的数列，F[i, j]表示从第i个数起连续2^j个数中的最大值。
例如数列3 2 4 5 6 8 1 2 9 7，
F[1，0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。
F[1，2]=5，F[1，3]=8，F[2，0]=2，F[2，1]=4……从这里可以看出F[i,0]其实就等于A[i]。
这样，DP的状态、初值都已经有了，剩下的就是状态转移方程。
我们把F[i，j]平均分成两段（因为f[i，j]一定是偶数个数字）。
从i到i+2^(j-1)-1为一段，i+2^(j-1)到i+2^j-1为一段(长度都为2^（j-1）)。
用上例说明，当i=1，j=3时就是3,2,4,5 和 6,8,1,2这两段。
F[i，j]就是这两段的最大值中的最大值。
于是我们得到了动态规划方程F[i, j]=max（F[i，j-1], F[i + 2^(j-1)，j-1]）。
 */
void Init(){
	int t = int(log(double(N)) / log(2.0));
	for (int j = 1; j <= t; j++){
		for (int i = 1; i + (1 << j) - 1 <= N; i++){
			dp[i][j] = max(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
		}
	}
}
int Query(int m){
	int len = N / m;
	int ans = 0;
	int k = int(log(double(len)) / log(2.0));
	for (int j = 0; j < m; j++){
		ans += max(dp[1 + j*len][k], dp[1 + j*len + len - (1 << k)][k]);
	}
	return ans;
}
